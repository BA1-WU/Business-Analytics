---
title: "01a-advanced data handling"
output:
  html_document:
    toc: yes
    df_print: paged
  html_notebook: default
  pdf_document:
    toc: yes
---
```{r, echo=FALSE}
library(knitr)
library(dplyr)
library(stringr)
options(scipen = F)
#This code automatically tidies code so that it does not reach over the page
opts_chunk$set(tidy.opts=list(width.cutoff=50),tidy=FALSE, rownames.print = FALSE, rows.print = 10, eval = TRUE)



top10_track_streams <- c(163608, 126687, 120480, 110022, 108630, 95639, 94690, 89011, 87869, 85599) 
top10_artist_names <- c("Axwell /\\ Ingrosso", "Imagine Dragons", "J. Balvin", "Robin Schulz", "Jonas Blue", "David Guetta", "French Montana", "Calvin Harris", "Liam Payne", "Lauv") # Characters have to be put in ""
top10_track_explicit <- c(0,0,0,0,0,0,1,1,0,0)
top10_track_explicit <- factor(top10_track_explicit, 
                               levels = c(0:1), 
                               labels = c("not explicit", "explicit"))
top10_artist_genre <- c("Dance","Alternative","Latino","Dance","Dance","Dance","Hip-Hop/Rap","Dance","Pop","Pop")
top10_artist_genre <- as.factor(top10_artist_genre)
top_10_track_release_date <- as.Date(c("2017-05-24", "2017-06-23", "2017-07-03", "2017-06-30", "2017-05-05", "2017-06-09", "2017-07-14", "2017-06-16", "2017-05-18", "2017-05-19"))
top10_track_explicit_1 <- c(FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,TRUE,FALSE,FALSE)  

music_data <- data.frame(top10_track_streams, 
                         top10_artist_names, 
                         top10_track_explicit, 
                         top10_artist_genre, 
                         top_10_track_release_date, 
                         top10_track_explicit_1,
                         stringsAsFactors = FALSE)

```


# Advanced data handling

This chapter covers more advanced techniques for handling data in R.

## The dplyr package

There are many ways to achieve the same thing in R. Data transformation and handling tasks can be solved with the functions provided by base R, but the ```dplyr```package offers a comprehensive suite of functions that makes many tasks easier, while keeping code very readable. As such we will be presenting it here, but keep in mind that all of these tasks could also be achieved without any packages. 

Before we continue, ensure that the ```dplyr()``` package is installed and loaded. 

### Filter rows

One of the most basic tasks one could wish to perform on a dataset is select certain observations based on various characteristics. ```dplyr``` uses the ```filter()``` function to this end. To select certain rows from a dataset you simply supply the data frame as the first argument and then tell ```filter()``` the logical criteria it should use to select observations. While this may sound fairly abstract, it will become very clear after a few examples.

Recall the ```music_data``` data frame from the previous chapter. Suppose we want to select only observations where the lyrics are not explicit. The code to achieve this would looks as follows:

```{r message=FALSE, warning=FALSE}
filter(music_data, top10_track_explicit == "not explicit")
```

The first argument supplied to the ```filter()``` function is the data frame we want to subset. The second argument tells ```filter()``` that we only want observations where the column ```top10_track_explicit``` is equal to the value ```"not explicit"```. If you look into the output you will notice that only tracks with non explicit lyrics have been returned.

Another way to filter observations is to choose all observations where one column is within a certain range. This can be achieved with the logical operators introduced in the basic data handling chapter. In the following example we select all tracks with less than 100000 streams. 

```{r message=FALSE, warning=FALSE}
filter(music_data, top10_track_streams < 100000)
```

You can enforce multiple conditions with ```&```. The following example selects all observations with less than 150000 but more than 100000 streams.

```{r message=FALSE, warning=FALSE}
filter(music_data,  top10_track_streams > 100000 & top10_track_streams < 150000)
```

The ```|``` symbol is the way R expresses "or". This way you can select observations that fulfill either one or the other condition. Say we would like to select all observations with less than 100000 or more than 150000 streams. The following code would do exactly that
```{r message=FALSE, warning=FALSE}
filter(music_data,  top10_track_streams < 100000 | top10_track_streams > 150000)
```

A very useful feature of the ```filter()``` function is its ability to accept multiple criteria at once. Say we want to select all tracks marked as ```"not explicit"``` with less than 100000 streams. This can be achieved by simply supplying the function with additional arguments, as in the example below. 

```{r message=FALSE, warning=FALSE}
filter(music_data, top10_track_explicit == "not explicit", top10_track_streams < 100000)
```

Below is an interactive version of the last command with the dataset preloaded. Feel free to experiment with various ways to specify rows to be extracted to get a feel for how the filter function works.

<iframe src="http://localhost:3838/dplyr_filter/?showcase=0" width="750" height="500",  frameBorder = 0>
</iframe>

### Select columns

Another common task is to select or exclude certain columns of a data frame. The ```dplyr``` package contains the ```select()``` function for exactly this purpose. Similarly to ```filter()``` you first supply the function with the data frame you wish to apply the selection to, followed by the columns you wish to select or exclude. 

The following code selects the two columns ```top10_track_explicit``` and  ```top10_track_streams``` from the ```music_data``` dataset. 

```{r message=FALSE, warning=FALSE}
select(music_data, top10_track_explicit, top10_track_streams)
```

Two remove columns from a dataframe you simply put a ```-``` before the column name. 

```{r message=FALSE, warning=FALSE}
select(music_data, -top10_track_explicit, -top10_track_streams)
```

You can also select or exclude a whole range of columns through numbers or names. 

```{r message=FALSE, warning=FALSE}
# Selects all columns from top10_track_explicit to top_10_track_release_date
select(music_data, top10_track_explicit:top_10_track_release_date)

# This is equivalent to  
select(music_data, 3:5)

```

Below you will again find an interactive version to experiment with. 

<iframe src="http://localhost:3838/dplyr_select/?showcase=0" width="750" height="500",  frameBorder = 0>
</iframe>

### Rename columns

Renaming of columns is done with a special version of the ```select()``` function called ```rename()```. The syntax may seem familiar at this point, with the first argument being the data frame to apply the function to and the following arguments being the transformations to apply. The example changes the names of the ```top10_track_explicit``` and ```top10_artist_names``` columns into ```explicit``` and ```names```, respectively.

```{r message=FALSE, warning=FALSE}
rename(music_data, explicit = top10_track_explicit, names = top10_artist_names)
```

### Arrange rows

If you just want to change the order of a data frame without discarding any observations or columns, you can use the ```arrange()``` function. It takes a data frame and a set of column names to order by, always in ascending order. If you provide more than one column name, each additional column will be used to break ties in the values of preceding columns.

```{r message=FALSE, warning=FALSE}
arrange(music_data, top10_artist_genre, top10_track_streams)
```

If you wish to arrange them in descending order, you can wrap the column name in the ```desc()``` function. 

```{r message=FALSE, warning=FALSE}
arrange(music_data, top10_artist_genre, desc(top10_track_streams))
```

Below you will again find an interactive version of the ```arrange()``` function to experiment with. 

<iframe src="http://localhost:3838/dplyr_arrange/?showcase=0" width="750" height="500",  frameBorder = 0>
</iframe>

### Adding and changing variables

There are two functions to create new variables based on other variables in the dplyr package, ```mutate()``` and ```transmutate()```. They both do the same thing, with one key difference: ```mutate()``` returns both the newly created variables _and_ the ones previously contained in the data frame, while ```transmutate()``` only returns the newly created variables. 

Both functions take variables already present in the dataset and apply a function to them to generate new variables. This can be something as simple as adding 1 to every entry in a column or more complex procedures, like standardising variables. The syntax is fairly straightforward: The first argument is the data frame we wish to apply the transformation to, and all the following arguments are the new variables we want to create. An exapmle will make this clearer. Say we (for some reason) want to add 10 to every entry of the ```top10_track_streams``` column in our dataset. The code to do this would look as follows:
```{r, message=FALSE, warning=FALSE}
mutate(music_data, streams_plus_10 = top10_track_streams + 10)
```

This code essentially defines a new column named ``` streams_plus_10```, which is the column ```top10_track_streams``` + 10. 

As previously mentioned, we can also perform more complex operations, such as standardising variables (i.e. subtracting the mean value and dividing by the standard deviation). Note that we are generating the mean and the standard deviation in our code by applying functions (```mean()``` and ```sd()```) to the entire column and then we use these values to perform the standardisation on _each_ value of the column.

```{r, message=FALSE, warning=FALSE}
mutate(music_data, streams_standardised = (top10_track_streams - mean(top10_track_streams))/ sd(top10_track_streams)) 
```

You can also add other vectors to an existing data frame with mutate, given that it is the same length as the data frame you want to add it to. 

```{r, message=FALSE, warning=FALSE, echo=FALSE}
set.seed(123)
```

```{r, message=FALSE, warning=FALSE}
# Generate random data with 10 rows
extra_column <- rnorm(nrow(music_data))

mutate(music_data, new_data = extra_column) 
```

### Changing variables

If you don't want to add a whole new variable and only want to edit a variable already present in the data frame, ```dplyr``` has you covered with the ```mutate_at()``` function. The practical thing about this function is that it can also be applied to a whole range of variables if you want to perform the same operation on multiple columns. To do this, you give the function not just a single column name, but a whole vector of column names. 

Say we first want to change the type of a single column. For example, maybe we want ```top10_track_explicit``` to be a character column and not a factor. We again tell ```mutate_at()``` which data frame we want to change, followed by the column(s) to change and finally the function we want to apply. You may have noticed that the column name is in quotation marks here, as opposed to the other functions we have met from the ```dplyr```package. This is a side effect of its ability to apply a function to a range of columns and not just a single one, as this can only be achieved via a character vector. So from a technical standpoint we are giving the ```mutate_at()``` function a character vector of length one, solely containg the element ```"top10_track_explicit"```.

```{r, message=FALSE, warning=FALSE}
mutate_at(music_data, "top10_track_explicit", as.character)
```

Now say we want to change multiple columns to be character vectors. To do this we will first create a vector of the names of the columns we want to apply the function to and then simply give ```mutate_at()```this vector as one of its arguments. If you do this, don't forget the ```c()``` function to create a vector. 

```{r, warning=FALSE, message=FALSE}
columns <- c("top10_track_explicit", "top10_artist_genre", "top10_track_explicit_1")

mutate_at(music_data, columns, as.character)
```

Below is again a version for you to experiment with. The vector ```extra_column``` from the last example has also been loaded into the environment, so you can try adding a whole new vector to the data frame. 

<iframe src="http://localhost:3838/dplyr_mutate/?showcase=0" width="750" height="500",  frameBorder = 0>
</iframe>

### Pipes

A very practical feature of the dplyr package are so called "pipes". Say you want to apply three of the previously mentioned functions to the same data frame. So far, the way we learned to do this would be as follows:


```{r, message=FALSE, warning=FALSE}
# First use select() to take only certain columns
music_data_new <- select(music_data, top10_track_explicit_1, top10_artist_names, top10_track_streams)

# Now use filter() to choose only rows that fulfill certain criteria 
music_data_new <- filter(music_data_new, top10_track_streams < 100000)

# Then change order with arrange()
music_data_new <- arrange(music_data_new, top10_track_streams)

# Print to console
music_data_new
```

While this does achieve our objective, it is quite tedious. With the pipes offered by ```dplyr```, you can chain these commands together to streamline your code, while keeping it very readable. The symbol for a pipe is ```%>%```. From a technical perspective, this hands the preceding object to the next function as the first argument. This may sound compicated, but will become clear after an example. The code below will create exactly the same data frame as the example above, but in a much more compact form.

```{r, message=FALSE, warning=FALSE}
music_data_new <- music_data %>%
  select(top10_track_explicit_1, top10_artist_names, top10_track_streams) %>%
  filter(top10_track_streams < 100000) %>%
  arrange(top10_track_streams)

# Print to console
music_data_new
```

Let's unpack what happened here. The first line "pipes" ```music_data``` into the first function, ```select()```, which is in the second line. Here we remove all columns except for ```top10_track_explicit_1```, ```top10_artist_names``` and ```top10_track_streams```. Then we take this data frame with the reduced columns and hand it to ```filter()```, which only selects observations with less than 100000 streams. Finally, we pass the filtered, column reduced data frame to arrange, which orders the rows by the number of streams per track. The assigment operator (```<-```) at the top then saves this data frame in the environment as ```music_new_data```. Note that, in contrast to the previous examples, we no longer have to specify which data frame we want to apply the various functions to, as the pipes take care of this for us.

Again, experiment with this feature below and it will quickly become very intuitive.

<iframe src="http://localhost:3838/dplyr_pipes/?showcase=0" width="750" height="500",  frameBorder = 0>
</iframe>

### Creating custom summaries

The ```summarise()``` function lets you build customised summaries of your data. This can range from creating means and standrad deviations of certain variables to simply counting how many observations are in a data frame. Say we want to find out the mean and standard deviation of the number of streams and also count the number of observations. With ``summarise()``` that would look as follows:

```{r, message=FALSE, warning=FALSE}
summarise(music_data, nObservations = n(), mean_streams = mean(top10_track_streams), sd_streams = sd(top10_track_streams))
```

On its own, this function is not that impressive. After all, we could just apply the ```mean()```, ```sd()``` and ```nrow()``` functions individually and would have gotten the same result, albeit not in such a nice format. 

However, when combined with the ```group_by()``` function, ```summarise()``` becomes very useful. ```group_by()``` splits a data frame into groups, by the values of a column in the data frame. Say we wanted to calculate the mean and standard deviation of explicit and non-explicit songs seperately. 

```{r, message=FALSE, warning=FALSE}
music_data %>%
  group_by(top10_track_explicit) %>%
  summarise(nObservations = n(), mean_streams = mean(top10_track_streams), sd_streams = sd(top10_track_streams))
```

This is a useful tool for getting a good overview of your data and potentially generating data for visualizations or tables. 

<iframe src="http://localhost:3838/dplyr_summarise/?showcase=0" width="750" height="500",  frameBorder = 0>
</iframe>

## Dealing with strings

Strings (which is short for "character strings"), can be tough to deal with. They are unstructured, messy and getting them into a format that one can perform analysis with is often a task that requires a lot of time. However, seeing as they appear fairly frequently in datasets and often contain valubale information, it is definitiely worth the time to learn how to deal with them.

### The ```stringr``` package

A very accesible package for manipulating strings is the ```stringr``` package. It is designed to be as uniform as possible, meaning that once you have understood the basic syntax of any one of its functions it is very easy to apply any of its functions. It sacrifices some flexibility for this simplicity, so if you ever encounter a task you can not easily solve with ```stringr``` it is worth checking out the package it is built on, ```stringi```. For now, however, ```stringr``` will be more than sufficient. 

The majority of functions in ```stringr``` are built around two core arguments: a string to be worked on and a pattern. There are quite a few that aren't, such as ```str_length()```, but these are (for the most part) fairly self explanatory and will not be explained further here. A full list of the included functions can be found [here](https://cran.r-project.org/web/packages/stringr/stringr.pdf).

The string to be worked on can either be an individual string in quotation marks or an entire vector or column of strings that the same operation should be applied to. The pattern can _technically_ also be a vector of patterns to look for, however, in this tutorial we will only use single patterns. 

Recall the list of artist names in the ```music_data``` data frame.

```{r, message=FALSE, warning=FALSE}
music_data$top10_artist_names
```

Say, for example, we want to see which names contain a "g". ```stringr``` contains the function ```str_detect```, which tells you exactly that. Note that these functions are all case sensitive, i.e. the "G" in "David Guetta" is not detected. 

```{r, message=FALSE, warning=FALSE}
str_detect(string = music_data$top10_artist_names, pattern = "g")
```

Say we want to be a bit more specific and want to know _exactly_ where the g is located in each artist name. ```str_locate_all``` returns a list of start and end values for each entry in the character vector.

```{r, warning=FALSE, message=FALSE}
str_locate_all(string = music_data$top10_artist_names, pattern = "g")
```

This obviously also works for patterns longer than just one letter.

```{r}
str_locate_all(string = music_data$top10_artist_names, pattern = "vin")
```

Another common task is to replace all instances of one character with another character. Say, for example, we want to replace all occurences of "a" with "b". The function ```str_replace_all()``` does exactly that. Note that there is also a function called ```str_replace()```, but this only replaces the *first*  match that the pattern finds. 

```{r, message=FALSE, warning=FALSE}
str_replace_all(music_data$top10_artist_names, pattern = "a", replacement = "b")
```

A common application for this function is to replace all "." with "," or vice versa in price data. R, for example, needs the decimal seperator to be a ".", so if you want to perform numerical analyses on price data that isn't in a uniform format, this function can be very useful. 

Say we want to replace all "." with "," in the artist names.

```{r, message=FALSE, warning=FALSE}
str_replace_all(music_data$top10_artist_names, pattern = ".", replacement = ",")
```

This result may be somewhat surprising. Why did the function replace _every_ character with "," even though we specified ```pattern = "."```? The explanation for this can be found in how the function matches patterns.

#### A crash course in regex

Behind the scenes ```stringr``` uses something called regex (short for "regular expressions") to match patterns. regex allows you to match not just individual letters, but more abstract patterns. It does this by special characters that do not match literally. You have already met the first such special character ".", which is regex's version of a wildcard, meaning that it matches _any_ other character. That's why, when we told stringr to replace all dots with commas, it replaced every character with a comma. 

This raises the question of what to do if we want to literally match a dot and not any character. There are two ways to go about this. First, we could *escape* the wildcard character. What this means is that we use another special character to tell regex that the next character is meant to be taken literally and not as a wildcard. The symbol for this is a double back slash "\\". So, if we wanted to change only the dot to a comma we would write

```{r, message=FALSE, warning=FALSE}
str_replace_all(music_data$top10_artist_names, pattern = "\\.", replacement = ",")
```

The second way to achieve this would be by passing the pattern string through the ```fixed()``` function, which tells ```stringr``` that it should take the entire string literally. This means that the following code achieves the same result as using "\\"

```{r, message=FALSE, warning=FALSE}
str_replace_all(music_data$top10_artist_names, pattern = fixed("."), replacement = ",")
```

##### 

## Case study 


