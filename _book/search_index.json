[
["advanced-data-handling.html", "3 Advanced data handling 3.1 The dplyr package 3.2 Filter rows 3.3 Select columns 3.4 Arrange rows 3.5 Add new variables 3.6 Pipes 3.7 Dealing with strings 3.8 group_by? 3.9 Case study", " 3 Advanced data handling This chapter covers more advanced techniques for handling data in R. 3.1 The dplyr package There are many ways to achieve the same thing in R. Data transformation and handling tasks can be solved with the functions provided by base R, but the dplyrpackage offers a comprehensive suite of functions that makes many tasks easier, while keeping code very readable. As such we will be presenting it here, but keep in mind that all of these tasks could also be achieved without any packages. 3.2 Filter rows One of the most basic tasks one could wish to perform on a dataset is select certain observations based on various characteristics. dplyr uses the filter() function to this end. To select certain rows from a dataset you simply supply the data frame as the first argument and then tell filter() the logical criteria it should use to select observations. While this may sound fairly abstract, it will become very clear after a few examples. Recall the music_data data frame from the previous chapter. Suppose we want to select only observations where the lyrics are not explicit. The code to achieve this would looks as follows: filter(music_data, top10_track_explicit == &quot;not explicit&quot;) The first argument supplied to the filter() function is the data frame we want to subset. The second argument tells filter() that we only want observations where the column top10_track_explicit is equal to the value &quot;not explicit&quot;. If you look into the output you will notice that only tracks with non explicit lyrics have been returned. Another way to filter observations is to choose all observations where one column is within a certain range. This can be achieved with the logical operators introduced in the basic data handling chapter. In the following example we select all tracks with less than 100000 streams. filter(music_data, top10_track_streams &lt; 100000) You can enforce multiple conditions with &amp;. The following example selects all observations with less than 150000 but more than 100000 streams. filter(music_data, top10_track_streams &gt; 100000 &amp; top10_track_streams &lt; 150000) The | symbol is the way R expresses “or”. This way you can select observations that fulfill either one or the other condition. Say we would like to select all observations with less than 100000 or more than 150000 streams. The following code would do exactly that filter(music_data, top10_track_streams &lt; 100000 | top10_track_streams &gt; 150000) A very useful feature of the filter() function is its ability to accept multiple criteria at once. Say we want to select all tracks marked as &quot;not explicit&quot; with less than 100000 streams. This can be achieved by simply supplying the function with additional arguments, as in the example below. filter(music_data, top10_track_explicit == &quot;not explicit&quot;, top10_track_streams &lt; 100000) Below is an interactive version of the last command with the dataset preloaded. Feel free to experiment with various ways to specify rows to be extracted to get a feel for how the filter function works. 3.3 Select columns Another common task is to select or exclude certain columns of a data frame. The dplyr package contains the select() function for exactly this purpose. Similarly to filter() you first supply the function with the data frame you wish to apply the selection to, followed by the columns you wish to select or exclude. The following code selects the two columns top10_track_explicit and top10_track_streams from the music_data dataset. select(music_data, top10_track_explicit, top10_track_streams) Two remove columns from a dataframe you simply put a - before the column name. select(music_data, -top10_track_explicit, -top10_track_streams) You can also select or exclude a whole range of columns through numbers or names. # Selects all columns from top10_track_explicit to top_10_track_release_date select(music_data, top10_track_explicit:top_10_track_release_date) # This is equivalent to select(music_data, 3:5) Below you will again find an interactive version to experiment with. 3.3.1 Rename columns Renaming of columns is done with a special version of the select() function called rename(). The syntax may seem familiar at this point, with the first argument being the data frame to apply the function to and the following arguments being the transformations to apply. The example changes the names of the top10_track_explicit and top10_artist_names columns into explicit and names, respectively. rename(music_data, explicit = top10_track_explicit, names = top10_artist_names) 3.4 Arrange rows If you just want to change the order of a data frame without discarding any observations or columns, you can use the arrange() function. It takes a data frame and a set of column names to order by, always in ascending order. If you provide more than one column name, each additional column will be used to break ties in the values of preceding columns. arrange(music_data, top10_artist_genre, top10_track_streams) If you wish to arrange them in descending order, you can wrap the column name in the desc() function. arrange(music_data, top10_artist_genre, desc(top10_track_streams)) Below you will again find an interactive version of the arrange() function to experiment with. 3.5 Add new variables There are two functions to create new variables based on other variables in the dplyr package, mutate() and transmutate(). They both do the same thing, with one key difference: mutate() returns both the newly created variables and the ones previously contained in the data frame, while transmutate() only returns the newly created variables. Both functions take variables already present in the dataset and apply a function to them to generate new variables. This can be something as simple as adding 1 to every entry in a column or more complex procedures, like standardising variables. The syntax is fairly straightforward: The first argument is the data frame we wish to apply the transformaion to, and all the following arguments are the new variables we want to create. An exapmle will make this clearer. Say we (for some reason) want to add 10 to every entry of the top10_track_streams in our dataset. The code to do this would look as follows: mutate(music_data, streams_plus_10 = top10_track_streams + 10) As previously mentioned, we can also perform more complex operations, such as standardising variables (i.e. subtracting the mean value and dividing by the standard deviation). mutate(music_data, streams_standardised = (top10_track_streams - mean(top10_track_streams))/ sd(top10_track_streams)) You can also add other vectors to an existing data frame with mutate, given that it is the same length as the data frame you want to add it to. # Generate random data with 10 rows extra_column &lt;- rnorm(nrow(music_data)) mutate(music_data, new_data = extra_column) Below is again a version for you to experiment with. The vector extra_column from the last example has also been loaded into the environment, so you can try adding a whole new vector to the data frame. 3.6 Pipes A very practical feature of the dplyr package are so called “pipes”. Say you want to apply three of the previously mentioned functions to the same data frame. So far, the way we learned to do this would be as follows: # First use select() to take only certain columns music_data_new &lt;- select(music_data, top10_track_explicit_1, top10_artist_names, top10_track_streams) # Now use filter() to choose only rows that fulfill certain criteria music_data_new &lt;- filter(music_data_new, top10_track_streams &lt; 100000) # Then change order with arrange() music_data_new &lt;- arrange(music_data_new, top10_track_streams) # Print to console music_data_new While this does achieve our objective, it is quite tedious. With the pipes offered by dplyr, you can chain these commands together to streamline your code, while keeping it very readable. The symbol for a pipe is %&gt;%. From a technical perspective, this hands the preceding object to the next function as the first argument. This may sound compicated, but will become clear after an example. The code below will create exactly the same data frame as the example above, but in a much more compact form. music_data_new &lt;- music_data %&gt;% select(top10_track_explicit_1, top10_artist_names, top10_track_streams) %&gt;% filter(top10_track_streams &lt; 100000) %&gt;% arrange(top10_track_streams) # Print to console music_data_new Let’s unpack what happened here. The first line “pipes” music_data into the first function, select(), which is in the second line. Here we remove all columns except for top10_track_explicit_1, top10_artist_names and top10_track_streams. Then we take this data frame with the reduced columns and hand it to filter(), which only selects observations with less than 100000 streams. Finally, we pass the filtered, column reduced data frame to arrange, which orders the rows by the number of streams per track. The assigment operator (&lt;-) at the top then saves this data frame in the environment as music_new_data. Note that, in contrast to the previous examples, we no longer have to specify which data frame we want to apply the various functions to, as the pipes take care of this for us. Again, experiment with this feature below and it will quickly become very intuitive. 3.7 Dealing with strings 3.8 group_by? 3.9 Case study "]
]
