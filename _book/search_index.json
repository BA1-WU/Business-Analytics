[
["advanced-data-handling.html", "3 Advanced data handling 3.1 The dplyr package 3.2 Dealing with strings 3.3 Case study", " 3 Advanced data handling This chapter covers more advanced techniques for handling data in R. 3.1 The dplyr package There are many ways to achieve the same thing in R. Data transformation and handling tasks can be solved with the functions provided by base R, but the dplyrpackage offers a comprehensive suite of functions that makes many tasks easier, while keeping code very readable. As such we will be presenting it here, but keep in mind that all of these tasks could also be achieved without any packages. Before we continue, ensure that the dplyr() package is installed and loaded. 3.1.1 Filter rows One of the most basic tasks one could wish to perform on a dataset is select certain observations based on various characteristics. dplyr uses the filter() function to this end. To select certain rows from a dataset you simply supply the data frame as the first argument and then tell filter() the logical criteria it should use to select observations. While this may sound fairly abstract, it will become very clear after a few examples. Recall the music_data data frame from the previous chapter. Suppose we want to select only observations where the lyrics are not explicit. The code to achieve this would looks as follows: filter(music_data, top10_track_explicit == &quot;not explicit&quot;) The first argument supplied to the filter() function is the data frame we want to subset. The second argument tells filter() that we only want observations where the column top10_track_explicit is equal to the value &quot;not explicit&quot;. If you look into the output you will notice that only tracks with non explicit lyrics have been returned. Another way to filter observations is to choose all observations where one column is within a certain range. This can be achieved with the logical operators introduced in the basic data handling chapter. In the following example we select all tracks with less than 100000 streams. filter(music_data, top10_track_streams &lt; 100000) You can enforce multiple conditions with &amp;. The following example selects all observations with less than 150000 but more than 100000 streams. filter(music_data, top10_track_streams &gt; 100000 &amp; top10_track_streams &lt; 150000) The | symbol is the way R expresses “or”. This way you can select observations that fulfill either one or the other condition. Say we would like to select all observations with less than 100000 or more than 150000 streams. The following code would do exactly that filter(music_data, top10_track_streams &lt; 100000 | top10_track_streams &gt; 150000) A very useful feature of the filter() function is its ability to accept multiple criteria at once. Say we want to select all tracks marked as &quot;not explicit&quot; with less than 100000 streams. This can be achieved by simply supplying the function with additional arguments, as in the example below. filter(music_data, top10_track_explicit == &quot;not explicit&quot;, top10_track_streams &lt; 100000) Below is an interactive version of the last command with the dataset preloaded. Feel free to experiment with various ways to specify rows to be extracted to get a feel for how the filter function works. 3.1.2 Select columns Another common task is to select or exclude certain columns of a data frame. The dplyr package contains the select() function for exactly this purpose. Similarly to filter() you first supply the function with the data frame you wish to apply the selection to, followed by the columns you wish to select or exclude. The following code selects the two columns top10_track_explicit and top10_track_streams from the music_data dataset. select(music_data, top10_track_explicit, top10_track_streams) Two remove columns from a dataframe you simply put a - before the column name. select(music_data, -top10_track_explicit, -top10_track_streams) You can also select or exclude a whole range of columns through numbers or names. # Selects all columns from top10_track_explicit to top_10_track_release_date select(music_data, top10_track_explicit:top_10_track_release_date) # This is equivalent to select(music_data, 3:5) Below you will again find an interactive version to experiment with. 3.1.3 Rename columns Renaming of columns is done with a special version of the select() function called rename(). The syntax may seem familiar at this point, with the first argument being the data frame to apply the function to and the following arguments being the transformations to apply. The example changes the names of the top10_track_explicit and top10_artist_names columns into explicit and names, respectively. rename(music_data, explicit = top10_track_explicit, names = top10_artist_names) 3.1.4 Arrange rows If you just want to change the order of a data frame without discarding any observations or columns, you can use the arrange() function. It takes a data frame and a set of column names to order by, always in ascending order. If you provide more than one column name, each additional column will be used to break ties in the values of preceding columns. arrange(music_data, top10_artist_genre, top10_track_streams) If you wish to arrange them in descending order, you can wrap the column name in the desc() function. arrange(music_data, top10_artist_genre, desc(top10_track_streams)) Below you will again find an interactive version of the arrange() function to experiment with. 3.1.5 Adding and changing variables There are two functions to create new variables based on other variables in the dplyr package, mutate() and transmutate(). They both do the same thing, with one key difference: mutate() returns both the newly created variables and the ones previously contained in the data frame, while transmutate() only returns the newly created variables. Both functions take variables already present in the dataset and apply a function to them to generate new variables. This can be something as simple as adding 1 to every entry in a column or more complex procedures, like standardising variables. The syntax is fairly straightforward: The first argument is the data frame we wish to apply the transformation to, and all the following arguments are the new variables we want to create. An exapmle will make this clearer. Say we (for some reason) want to add 10 to every entry of the top10_track_streams column in our dataset. The code to do this would look as follows: mutate(music_data, streams_plus_10 = top10_track_streams + 10) This code essentially defines a new column named streams_plus_10, which is the column top10_track_streams + 10. As previously mentioned, we can also perform more complex operations, such as standardising variables (i.e. subtracting the mean value and dividing by the standard deviation). Note that we are generating the mean and the standard deviation in our code by applying functions (mean() and sd()) to the entire column and then we use these values to perform the standardisation on each value of the column. mutate(music_data, streams_standardised = (top10_track_streams - mean(top10_track_streams))/ sd(top10_track_streams)) You can also add other vectors to an existing data frame with mutate, given that it is the same length as the data frame you want to add it to. # Generate random data with 10 rows extra_column &lt;- rnorm(nrow(music_data)) mutate(music_data, new_data = extra_column) 3.1.6 Changing variables If you don’t want to add a whole new variable and only want to edit a variable already present in the data frame, dplyr has you covered with the mutate_at() function. The practical thing about this function is that it can also be applied to a whole range of variables if you want to perform the same operation on multiple columns. To do this, you give the function not just a single column name, but a whole vector of column names. Say we first want to change the type of a single column. For example, maybe we want top10_track_explicit to be a character column and not a factor. We again tell mutate_at() which data frame we want to change, followed by the column(s) to change and finally the function we want to apply. You may have noticed that the column name is in quotation marks here, as opposed to the other functions we have met from the dplyrpackage. This is a side effect of its ability to apply a function to a range of columns and not just a single one, as this can only be achieved via a character vector. So from a technical standpoint we are giving the mutate_at() function a character vector of length one, solely containg the element &quot;top10_track_explicit&quot;. mutate_at(music_data, &quot;top10_track_explicit&quot;, as.character) Now say we want to change multiple columns to be character vectors. To do this we will first create a vector of the names of the columns we want to apply the function to and then simply give mutate_at()this vector as one of its arguments. If you do this, don’t forget the c() function to create a vector. columns &lt;- c(&quot;top10_track_explicit&quot;, &quot;top10_artist_genre&quot;, &quot;top10_track_explicit_1&quot;) mutate_at(music_data, columns, as.character) Below is again a version for you to experiment with. The vector extra_column from the last example has also been loaded into the environment, so you can try adding a whole new vector to the data frame. 3.1.7 Pipes A very practical feature of the dplyr package are so called “pipes”. Say you want to apply three of the previously mentioned functions to the same data frame. So far, the way we learned to do this would be as follows: # First use select() to take only certain columns music_data_new &lt;- select(music_data, top10_track_explicit_1, top10_artist_names, top10_track_streams) # Now use filter() to choose only rows that fulfill certain criteria music_data_new &lt;- filter(music_data_new, top10_track_streams &lt; 100000) # Then change order with arrange() music_data_new &lt;- arrange(music_data_new, top10_track_streams) # Print to console music_data_new While this does achieve our objective, it is quite tedious. With the pipes offered by dplyr, you can chain these commands together to streamline your code, while keeping it very readable. The symbol for a pipe is %&gt;%. From a technical perspective, this hands the preceding object to the next function as the first argument. This may sound compicated, but will become clear after an example. The code below will create exactly the same data frame as the example above, but in a much more compact form. music_data_new &lt;- music_data %&gt;% select(top10_track_explicit_1, top10_artist_names, top10_track_streams) %&gt;% filter(top10_track_streams &lt; 100000) %&gt;% arrange(top10_track_streams) # Print to console music_data_new Let’s unpack what happened here. The first line “pipes” music_data into the first function, select(), which is in the second line. Here we remove all columns except for top10_track_explicit_1, top10_artist_names and top10_track_streams. Then we take this data frame with the reduced columns and hand it to filter(), which only selects observations with less than 100000 streams. Finally, we pass the filtered, column reduced data frame to arrange, which orders the rows by the number of streams per track. The assigment operator (&lt;-) at the top then saves this data frame in the environment as music_new_data. Note that, in contrast to the previous examples, we no longer have to specify which data frame we want to apply the various functions to, as the pipes take care of this for us. Again, experiment with this feature below and it will quickly become very intuitive. 3.1.8 Creating custom summaries The summarise() function lets you build customised summaries of your data. This can range from creating means and standrad deviations of certain variables to simply counting how many observations are in a data frame. Say we want to find out the mean and standard deviation of the number of streams and also count the number of observations. With ``summarise()``` that would look as follows: summarise(music_data, nObservations = n(), mean_streams = mean(top10_track_streams), sd_streams = sd(top10_track_streams)) On its own, this function is not that impressive. After all, we could just apply the mean(), sd() and nrow() functions individually and would have gotten the same result, albeit not in such a nice format. However, when combined with the group_by() function, summarise() becomes very useful. group_by() splits a data frame into groups, by the values of a column in the data frame. Say we wanted to calculate the mean and standard deviation of explicit and non-explicit songs seperately. music_data %&gt;% group_by(top10_track_explicit) %&gt;% summarise(nObservations = n(), mean_streams = mean(top10_track_streams), sd_streams = sd(top10_track_streams)) This is a useful tool for getting a good overview of your data and potentially generating data for visualizations or tables. 3.2 Dealing with strings Strings (which is short for “character strings”), can be tough to deal with. They are unstructured, messy and getting them into a format that one can perform analysis with is often a task that requires a lot of time. However, seeing as they appear fairly frequently in datasets and often contain valubale information, it is definitiely worth the time to learn how to deal with them. 3.2.1 The stringr package A very accesible package for manipulating strings is the stringr package. It is designed to be as uniform as possible, meaning that once you have understood the basic syntax of any one of its functions it is very easy to apply any of its functions. It sacrifices some flexibility for this simplicity, so if you ever encounter a task you can not easily solve with stringr it is worth checking out the package it is built on, stringi. For now, however, stringr will be more than sufficient. The majority of functions in stringr are built around two core arguments: a string to be worked on and a pattern. There are quite a few that aren’t, such as str_length(), but these are (for the most part) fairly self explanatory and will not be explained further here. A full list of the included functions can be found here. The string to be worked on can either be an individual string in quotation marks or an entire vector or column of strings that the same operation should be applied to. The pattern can technically also be a vector of patterns to look for, however, in this tutorial we will only use single patterns. Recall the list of artist names in the music_data data frame. music_data$top10_artist_names ## [1] &quot;Axwell /\\\\ Ingrosso&quot; &quot;Imagine Dragons&quot; &quot;J. Balvin&quot; ## [4] &quot;Robin Schulz&quot; &quot;Jonas Blue&quot; &quot;David Guetta&quot; ## [7] &quot;French Montana&quot; &quot;Calvin Harris&quot; &quot;Liam Payne&quot; ## [10] &quot;Lauv&quot; Say, for example, we want to see which names contain a “g”. stringr contains the function str_detect, which tells you exactly that. Note that these functions are all case sensitive, i.e. the “G” in “David Guetta” is not detected. str_detect(string = music_data$top10_artist_names, pattern = &quot;g&quot;) ## [1] TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE Say we want to be a bit more specific and want to know exactly where the g is located in each artist name. str_locate_all returns a list of start and end values for each entry in the character vector. str_locate_all(string = music_data$top10_artist_names, pattern = &quot;g&quot;) ## [[1]] ## start end ## [1,] 13 13 ## ## [[2]] ## start end ## [1,] 4 4 ## [2,] 12 12 ## ## [[3]] ## start end ## ## [[4]] ## start end ## ## [[5]] ## start end ## ## [[6]] ## start end ## ## [[7]] ## start end ## ## [[8]] ## start end ## ## [[9]] ## start end ## ## [[10]] ## start end This obviously also works for patterns longer than just one letter. str_locate_all(string = music_data$top10_artist_names, pattern = &quot;vin&quot;) ## [[1]] ## start end ## ## [[2]] ## start end ## ## [[3]] ## start end ## [1,] 7 9 ## ## [[4]] ## start end ## ## [[5]] ## start end ## ## [[6]] ## start end ## ## [[7]] ## start end ## ## [[8]] ## start end ## [1,] 4 6 ## ## [[9]] ## start end ## ## [[10]] ## start end Another common task is to replace all instances of one character with another character. Say, for example, we want to replace all occurences of “a” with “b”. The function str_replace_all() does exactly that. Note that there is also a function called str_replace(), but this only replaces the first match that the pattern finds. str_replace_all(music_data$top10_artist_names, pattern = &quot;a&quot;, replacement = &quot;b&quot;) ## [1] &quot;Axwell /\\\\ Ingrosso&quot; &quot;Imbgine Drbgons&quot; &quot;J. Bblvin&quot; ## [4] &quot;Robin Schulz&quot; &quot;Jonbs Blue&quot; &quot;Dbvid Guettb&quot; ## [7] &quot;French Montbnb&quot; &quot;Cblvin Hbrris&quot; &quot;Libm Pbyne&quot; ## [10] &quot;Lbuv&quot; A common application for this function is to replace all “.” with “,” or vice versa in price data. R, for example, needs the decimal seperator to be a “.”, so if you want to perform numerical analyses on price data that isn’t in a uniform format, this function can be very useful. Say we want to replace all “.” with “,” in the artist names. str_replace_all(music_data$top10_artist_names, pattern = &quot;.&quot;, replacement = &quot;,&quot;) ## [1] &quot;,,,,,,,,,,,,,,,,,,&quot; &quot;,,,,,,,,,,,,,,,&quot; &quot;,,,,,,,,,&quot; ## [4] &quot;,,,,,,,,,,,,&quot; &quot;,,,,,,,,,,&quot; &quot;,,,,,,,,,,,,&quot; ## [7] &quot;,,,,,,,,,,,,,,&quot; &quot;,,,,,,,,,,,,,&quot; &quot;,,,,,,,,,,&quot; ## [10] &quot;,,,,&quot; This result may be somewhat surprising. Why did the function replace every character with “,” even though we specified pattern = &quot;.&quot;? The explanation for this can be found in how the function matches patterns. 3.2.2 A crash course in regex Behind the scenes stringr uses something called regex (short for “regular expressions”) to match patterns. regex allows you to match not just individual letters, but more abstract patterns. It does this by using special characters that do not match literally. You have already met the first such special character “.”, which is regex’s version of a wildcard, meaning that it matches any other character. That’s why, when we told stringr to replace all dots with commas, it replaced every character with a comma. This raises the question of what to do if we want to literally match a dot and not any character. There are two ways to go about this. First, we could escape the wildcard character. What this means is that we use another special character to tell regex that the next character is meant to be taken literally and not as a wildcard. The symbol for this is a double back slash “\\”. So, if we wanted to change only the dot to a comma we would write str_replace_all(music_data$top10_artist_names, pattern = &quot;\\\\.&quot;, replacement = &quot;,&quot;) ## [1] &quot;Axwell /\\\\ Ingrosso&quot; &quot;Imagine Dragons&quot; &quot;J, Balvin&quot; ## [4] &quot;Robin Schulz&quot; &quot;Jonas Blue&quot; &quot;David Guetta&quot; ## [7] &quot;French Montana&quot; &quot;Calvin Harris&quot; &quot;Liam Payne&quot; ## [10] &quot;Lauv&quot; The second way to achieve this would be by passing the pattern string through the fixed() function, which tells stringr that it should take the entire string literally. This means that the following code achieves the same result as using “\\”. str_replace_all(music_data$top10_artist_names, pattern = fixed(&quot;.&quot;), replacement = &quot;,&quot;) ## [1] &quot;Axwell /\\\\ Ingrosso&quot; &quot;Imagine Dragons&quot; &quot;J, Balvin&quot; ## [4] &quot;Robin Schulz&quot; &quot;Jonas Blue&quot; &quot;David Guetta&quot; ## [7] &quot;French Montana&quot; &quot;Calvin Harris&quot; &quot;Liam Payne&quot; ## [10] &quot;Lauv&quot; 3.2.2.1 Other special characters in regex We will quickly go through the most important regex special characters. Be aware that this list is by no means exhautive and is only meant to give you some basic tools that can help you with string manipulation. Keep this in mind if a regex is displaying unexpected behaviour, as it could be due to some wildcard you are not aware of. If all else fails you can always used the fixed() function to just match literal strings. 3.2.2.1.1 Square brackets [] Square brackets can be used to match from a set of different letters. This means that [abc] will match a, b or c. The following code will replace a, b or c with a capital X. str_replace_all(music_data$top10_artist_names, pattern = &quot;[abc]&quot;, replacement = &quot;X&quot;) ## [1] &quot;Axwell /\\\\ Ingrosso&quot; &quot;ImXgine DrXgons&quot; &quot;J. BXlvin&quot; ## [4] &quot;RoXin SXhulz&quot; &quot;JonXs Blue&quot; &quot;DXvid GuettX&quot; ## [7] &quot;FrenXh MontXnX&quot; &quot;CXlvin HXrris&quot; &quot;LiXm PXyne&quot; ## [10] &quot;LXuv&quot; Note again that this is case sensitive, meaning that A, B and C are not replaced. However, square brackets are a great way to replace both capitalized and non-capitalized occurences at once. str_replace_all(music_data$top10_artist_names, pattern = &quot;[ABCabc]&quot;, replacement = &quot;X&quot;) ## [1] &quot;Xxwell /\\\\ Ingrosso&quot; &quot;ImXgine DrXgons&quot; &quot;J. XXlvin&quot; ## [4] &quot;RoXin SXhulz&quot; &quot;JonXs Xlue&quot; &quot;DXvid GuettX&quot; ## [7] &quot;FrenXh MontXnX&quot; &quot;XXlvin HXrris&quot; &quot;LiXm PXyne&quot; ## [10] &quot;LXuv&quot; If you include a ^ in the beginning of a square bracket pattern, regex will interpret that to mean any character except the ones in brackets. This means that if we take the same code as before and include a ^, all letters except for A, B and C (and their non-capitalized counterparts) will be replaced by a capital X. str_replace_all(music_data$top10_artist_names, pattern = &quot;[^ABCabc]&quot;, replacement = &quot;X&quot;) ## [1] &quot;AXXXXXXXXXXXXXXXXX&quot; &quot;XXaXXXXXXXaXXXX&quot; &quot;XXXBaXXXX&quot; ## [4] &quot;XXbXXXXcXXXX&quot; &quot;XXXaXXBXXX&quot; &quot;XaXXXXXXXXXa&quot; ## [7] &quot;XXXXcXXXXXXaXa&quot; &quot;CaXXXXXXaXXXX&quot; &quot;XXaXXXaXXX&quot; ## [10] &quot;XaXX&quot; 3.2.2.1.2 Repetition operators: *,+ and {} Repetition operators can be used to match the same character (or set of characters) multiple times. + matches a character one or more times, * matches a character zero or more times and with {} you can specfiy the range that matches can occur in. vector &lt;- c(&quot;&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, &quot;aaaa&quot;) # Replace one or more a with an X str_replace(vector, pattern = &quot;a+&quot;, replacement = &quot;X&quot;) ## [1] &quot;&quot; &quot;X&quot; &quot;X&quot; &quot;X&quot; &quot;X&quot; # replace zero or more a with an X str_replace(vector, pattern = &quot;a*&quot;, replacement = &quot;X&quot;) ## [1] &quot;X&quot; &quot;X&quot; &quot;X&quot; &quot;X&quot; &quot;X&quot; # replace exactly two a with an X str_replace(vector, pattern = &quot;a{2}&quot;, replacement = &quot;X&quot;) ## [1] &quot;&quot; &quot;a&quot; &quot;X&quot; &quot;Xa&quot; &quot;Xaa&quot; # replace two to three a with an X str_replace(vector, pattern = &quot;a{2,3}&quot;, replacement = &quot;X&quot;) ## [1] &quot;&quot; &quot;a&quot; &quot;X&quot; &quot;X&quot; &quot;Xa&quot; Note that the + and * operators are “greedy”, meaning that they try to match as much as possible, which can often lead to unintended consequences. It is often a good practice with regex to be as specific as possible while remaining as general as needed. 3.2.2.1.3 Parentheses: () Parentheses are used to create groups. Groups always match in their entirety and can be combined with other operators. vector &lt;- c(&quot;abc&quot;, &quot;abcabc&quot;, &quot;123abc&quot;, &quot;abcabcabc&quot;) str_replace_all(vector, pattern = &quot;(abc){2}&quot;, replacement = &quot;X&quot;) ## [1] &quot;abc&quot; &quot;X&quot; &quot;123abc&quot; &quot;Xabc&quot; The pattern &quot;(abc){2}&quot; will match only &quot;abcabc&quot;, seeing as it looks for matches that repeat the group &quot;(abc)&quot; twice. 3.2.2.1.4 Optional characters: ? The question mark tells regex that the preceding character is optional for a match. vector &lt;- c(&quot;abc&quot;, &quot;ac&quot;) str_replace_all(vector, pattern = &quot;abc&quot;, replacement = &quot;X&quot;) ## [1] &quot;X&quot; &quot;ac&quot; As expected, this only replaces the first element of the vector, as the second (&quot;ac&quot;) is not an exact match. str_replace_all(vector, pattern = &quot;ab?c&quot;, replacement = &quot;X&quot;) ## [1] &quot;X&quot; &quot;X&quot; By including ? after the b, we tell regex that it is optional, i.e. that both &quot;abc&quot; and &quot;ac&quot; are correct matches. This can also be applied to groups and sets. 3.3 Case study "]
]
